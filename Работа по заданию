Запуск: make qemu
Выход: Ctrl + A, затем X

Запуск в Отладчике (GDB):
make qemu-gdb

В отдельной вкладке:
riscv64-unknown-elf-gdb

И подключаемся к xv6 командой:
target remote localhost:26000

Точки Останова:
break main
continue

Выход из отладчика:
quit


Задача 1.
Задача состоит из трех частей, где нужно реализовать утилиту, которая:

Читает строку из терминала, содержащую два числа, разделённых пробелом.
Преобразует оба числа в int.
Вычисляет их сумму и выводит в терминал.
Нужно три реализации:

(a) На ассемблере с использованием gets и printf.
(b) На C с gets и printf.
(c) На C, но с использованием системного вызова read вместо gets.


Как работают пользовательские программы в xv6?:
В xv6 есть специальная директория user/, в которой хранятся исходники пользовательских программ (ls.c, echo.c, cat.c...)

Файлы пользовательских программ компилируются в исполняемые файлы и затем включаются в файловую систему xv6.
gets() — это функция, объявленная в ulib.c, которая использует системный вызов read() для чтения строки.
printf() — это функция вывода, объявленная в printf.c, она работает с системными вызовами write().
atoi() — функция преобразования строки в число, объявлена в ulib.c.



Создаем новую утилиту в xv6:

Добавить новый файл, например, sum_read.c, в каталог user/.
Написать код программы внутри этого файла.
Добавить файл в Makefile, чтобы он компилировался и включался в xv6.
Запустить make qemu и протестировать программу в xv6.



Добавим в хѵ6 системный вызов sys_add:

Добавим объявление системного вызова в kernel/syscall.h:
#define SYS_add    22
В kernel/syscall.c добавим:
extern uint64 sys_add(void);
[SYS_add]	  sys_add,
Создадим реализацию в kernel/sysproc.c ...
В user/user.h добавим объявление:
int add(int, int);
В user/usys.pl добавим:
entry("add");
Создадим тестовую утилиту user/sys_add_test.c:
Пересобираем
Проверяем

